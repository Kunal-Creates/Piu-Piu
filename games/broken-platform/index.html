<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Broken Platform</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.58/Tone.js"></script>
    <style>
        /* Custom CSS for retro look and feel */
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a1a1a; /* Dark background */
            color: #00ff00; /* Retro green text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* Prevent scrolling */
            position: relative; /* Needed for absolute positioning of controls */
        }

        #game-container {
            text-align: center;
            background-color: #333; /* Darker grey container */
            padding: 20px;
            border: 4px solid #00ff00; /* Retro green border */
            box-shadow: 0 0 10px #00ff00; /* Retro green glow */
            border-radius: 8px;
            max-width: 95%; /* Max width for responsiveness */
            width: 600px; /* Preferred width */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* Needed for positioning controls relative to container */
        }

        #start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            z-index: 5; /* Above canvas */
        }

        #start-screen h1 {
            font-size: 1.5rem; /* Responsive font size */
            margin-bottom: 20px;
            color: #00ffff; /* Cyan for title */
        }

        .game-button {
            font-family: 'Press Start 2P', cursive;
            background-color: #00ff00; /* Retro green button */
            color: #1a1a1a; /* Dark text */
            border: none;
            padding: 15px 25px;
            margin: 10px;
            font-size: 1rem; /* Responsive font size */
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            box-shadow: 0 4px #00cc00; /* Darker green shadow */
        }

        .game-button:hover {
            background-color: #00cc00; /* Darker green on hover */
        }

        .game-button:active {
            background-color: #009900; /* Even darker green on active */
            transform: translateY(2px); /* Press effect */
            box-shadow: 0 2px #009900;
        }

        canvas {
            border: 2px solid #00ff00; /* Retro green border for canvas */
            background-color: #222; /* Slightly lighter dark for canvas background */
            display: block;
            margin: 0 auto; /* Center the canvas */
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
            z-index: 1; /* Below controls and screens */
        }

        #game-info {
            margin-top: 10px;
            font-size: 0.8rem; /* Smaller font for info */
            color: #ffff00; /* Yellow for info text */
            z-index: 5;
        }

        #game-over-screen {
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent dark overlay */
            position: absolute; /* Position over the game */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10; /* Above the canvas and controls */
        }

        #game-over-screen h2 {
            font-size: 2rem;
            color: #ff0000; /* Red for game over */
            margin-bottom: 20px;
        }

        #game-over-screen p {
            font-size: 1.2rem;
            color: #00ffff; /* Cyan for winner info */
            margin-bottom: 20px;
        }

        .hidden {
            display: none;
        }

        /* Mobile Controls Styling */
        #mobile-controls {
            display: none; /* Hidden by default, shown on small screens */
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5; /* Above canvas */
        }

        .control-row {
            display: flex;
            justify-content: center;
        }

        .control-button {
            font-family: 'Press Start 2P', cursive;
            background-color: #555; /* Dark grey */
            color: #00ff00; /* Retro green */
            border: 2px solid #00ff00;
            padding: 15px;
            margin: 5px;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 4px;
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            touch-action: manipulation; /* Prevent double tap zoom */
        }

        .control-button:active {
            background-color: #777; /* Lighter grey on active */
        }

        /* Show mobile controls on screens smaller than a certain breakpoint */
        @media (max-width: 768px) {
            #mobile-controls {
                display: block;
            }
             /* Hide keyboard controls info on mobile */
            #game-info {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="start-screen">
            <h1>Broken Platform</h1>
            <button class="game-button" id="single-player-btn">Single Player</button>
            <button class="game-button" id="two-player-btn">Two Player</button>
        </div>

        <canvas id="gameCanvas"></canvas>
        <div id="game-info">Use Arrow Keys (P1) and WASD (P2) to move</div>

        <div id="game-over-screen" class="hidden">
            <h2>Game Over!</h2>
            <p id="winner-info"></p>
            <button class="game-button" id="main-menu-button">Main Menu</button> </div>

        <div id="mobile-controls">
            <div class="control-row">
                <button class="control-button" data-direction="up">▲</button>
            </div>
            <div class="control-row">
                <button class="control-button" data-direction="left">◀</button>
                <button class="control-button" data-direction="down">▼</button>
                <button class="control-button" data-direction="right">▶</button>
            </div>
        </div>

    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const winnerInfo = document.getElementById('winner-info');
        const mainMenuButton = document.getElementById('main-menu-button'); // Changed restartButton to mainMenuButton
        const gameInfo = document.getElementById('game-info');
        const mobileControls = document.getElementById('mobile-controls');
        const controlButtons = mobileControls.querySelectorAll('.control-button');


        const singlePlayerBtn = document.getElementById('single-player-btn');
        const twoPlayerBtn = document.getElementById('two-player-btn');

        let gameMode = null; // 'single' or 'two'
        let gameRunning = false;

        // Game settings
        const GRID_SIZE = 8; // 8x8 grid
        const BLOCK_SIZE = 60; // Size of each block in pixels
        const BLOCK_GAP = 5; // Gap between blocks
        const BREAK_TIME = 2000; // Time in ms before a block breaks after being left
        const WARNING_TIME = 1000; // Time in ms for warning color shift before breaking

        // Colors (monochrome palette)
        const COLORS = {
            BLOCK_SOLID: '#aaaaaa', // Light grey for solid blocks
            BLOCK_WARNING: '#777777', // Darker grey for warning
            BLOCK_BROKEN: '#444444', // Even darker grey for broken
            PLAYER1: '#00ffff', // Cyan for Player 1
            PLAYER2: '#ffff00', // Yellow for Player 2
            BACKGROUND: '#222222' // Canvas background
        };

        let grid = [];
        let players = [];
        let playerSize = BLOCK_SIZE * 0.6; // Player size relative to block

        // Sound Effects - Declare variables here, initialize in initGame
        let moveSynth;
        let breakSynth;


        // Player object structure
        class Player {
            constructor(id, x, y, color, controls) {
                this.id = id;
                this.gridX = x;
                this.gridY = y;
                this.color = color;
                this.controls = controls; // Object with key codes or null for AI
                this.isAlive = true;
                this.moveTimer = 0; // Timer to prevent rapid movement
                this.moveDelay = 150; // Delay between moves in ms
            }

            draw() {
                if (!this.isAlive) return;
                const centerX = this.gridX * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_SIZE / 2 + BLOCK_GAP;
                const centerY = this.gridY * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_SIZE / 2 + BLOCK_GAP;

                ctx.fillStyle = this.color;
                ctx.fillRect(
                    centerX - playerSize / 2,
                    centerY - playerSize / 2,
                    playerSize,
                    playerSize
                );

                // Simple pixelated effect for players
                ctx.fillStyle = '#000'; // Black eyes/details
                if (this.isAlive) {
                     // Example pixel eyes
                    ctx.fillRect(centerX - playerSize / 4, centerY - playerSize / 8, playerSize / 8, playerSize / 8);
                    ctx.fillRect(centerX + playerSize / 8, centerY - playerSize / 8, playerSize / 8, playerSize / 8);
                }
            }

            move(dx, dy) {
                if (!this.isAlive || Date.now() - this.moveTimer < this.moveDelay) return;

                const newGridX = this.gridX + dx;
                const newGridY = this.gridY + dy;

                // Check bounds
                if (newGridX >= 0 && newGridX < GRID_SIZE && newGridY >= 0 && newGridY < GRID_SIZE) {
                    const oldGridX = this.gridX;
                    const oldGridY = this.gridY;

                    this.gridX = newGridX;
                    this.gridY = newGridY;
                    this.moveTimer = Date.now();

                    // Play move sound if synths are initialized
                    if (moveSynth) {
                        moveSynth.triggerAttackRelease('C4', '8n');
                    }

                    // --- Block Breaking Logic Fix ---

                    // Handle the block the player just left
                    const prevBlockIndex = oldGridY * GRID_SIZE + oldGridX;
                    if (prevBlockIndex >= 0 && prevBlockIndex < grid.length) { // Check if index is valid
                        const prevBlock = grid[prevBlockIndex];
                        if (prevBlock.state !== 'broken') { // Only start timer if not already broken
                             // Check if any other player is still on the block being left
                             const otherPlayerPresent = players.some(p =>
                                 p.isAlive && p !== this && p.gridX === oldGridX && p.gridY === oldGridY
                             );

                             if (!otherPlayerPresent) {
                                 // If no other player is on the block being left, start its break timer
                                 if (prevBlock.state === 'solid') { // Only transition from solid
                                     prevBlock.state = 'warning';
                                     prevBlock.breakTime = Date.now() + BREAK_TIME;
                                     prevBlock.warningTime = Date.now() + WARNING_TIME;
                                 }
                             }
                        }
                    }


                    // Handle the block the player landed on
                    const currentBlockIndex = this.gridY * GRID_SIZE + this.gridX;
                     if (currentBlockIndex >= 0 && currentBlockIndex < grid.length) { // Check if index is valid
                        const currentBlock = grid[currentBlockIndex];
                        if (currentBlock.state === 'solid') {
                            // If the block is solid, start its break timer immediately upon landing
                            currentBlock.state = 'warning';
                            currentBlock.breakTime = Date.now() + BREAK_TIME;
                            currentBlock.warningTime = Date.now() + WARNING_TIME;
                        }
                        // If the block is already in 'warning' state, its timer is already running, no need to reset.
                     }

                    // --- End Block Breaking Logic Fix ---

                }
            }
        }

        // Block object structure
        class Block {
            constructor(x, y) {
                this.gridX = x;
                this.gridY = y;
                this.state = 'solid'; // 'solid', 'warning', 'broken'
                this.breakTime = null; // Timestamp when the block should break
                this.warningTime = null; // Timestamp when the block should show warning color
                this.animationTimer = 0; // For simple animation effects
                this.animationDuration = 100; // Duration of animation
            }

            draw() {
                let color = COLORS.BLOCK_SOLID;
                if (this.state === 'warning') {
                    color = COLORS.BLOCK_WARNING;
                } else if (this.state === 'broken') {
                    color = COLORS.BLOCK_BROKEN;
                }

                ctx.fillStyle = color;
                ctx.fillRect(
                    this.gridX * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_GAP,
                    this.gridY * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_GAP,
                    BLOCK_SIZE,
                    BLOCK_SIZE
                );

                // Simple animation: quick fade/pulse effect when warning
                if (this.state === 'warning') {
                    const elapsed = Date.now() - (this.breakTime - BREAK_TIME);
                    const progress = elapsed / BREAK_TIME;
                    const alpha = 1 - Math.sin(progress * Math.PI); // Simple pulsing effect

                    ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`; // Green pulse
                     ctx.fillRect(
                        this.gridX * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_GAP,
                        this.gridY * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_GAP,
                        BLOCK_SIZE,
                        BLOCK_SIZE
                    );
                }
            }

            update() {
                if (this.state === 'broken') return;

                const now = Date.now();

                if (this.state === 'warning' && this.breakTime && now >= this.breakTime) {
                    this.state = 'broken';
                    this.breakTime = null; // Reset break time
                    this.warningTime = null; // Reset warning time
                    // Play break sound if synth is initialized
                    if (breakSynth) {
                        breakSynth.triggerAttackRelease('8n');
                    }
                } else if (this.state === 'solid' && this.warningTime && now >= this.warningTime) {
                     // This transition is now handled in player.move when landing on a solid block
                     // This part might be redundant now, but keeping it for safety or future logic
                     // if (this.state === 'solid') { // Ensure it's still solid before transitioning
                     //     this.state = 'warning';
                     // }
                     this.warningTime = null; // Reset warning time after transition
                }
            }
        }

        function initGame(mode) {
            gameMode = mode;
            gameRunning = true;
            startScreen.classList.add('hidden'); // Hide start screen
            gameOverScreen.classList.add('hidden');
            canvas.style.display = 'block'; // Show canvas
            mobileControls.style.display = window.innerWidth <= 768 ? 'block' : 'none'; // Show controls if on mobile size

            // Initialize Sound Effects Synths here to ensure Tone.js is loaded
            if (typeof Tone !== 'undefined') {
                // Check if context is running, if not, start it (needed for some browsers)
                if (Tone.context.state !== 'running') {
                    Tone.context.resume();
                }
                moveSynth = new Tone.Synth().toDestination();
                breakSynth = new Tone.NoiseSynth().toDestination();
            } else {
                console.warn("Tone.js not loaded. Sound effects will be disabled.");
                moveSynth = null; // Ensure synths are null if Tone is not available
                breakSynth = null;
            }


            // Initialize grid
            grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    grid.push(new Block(x, y));
                }
            }

            // Initialize players
            players = [];
            // Player 1 (Top-left corner)
            players.push(new Player(1, 0, 0, COLORS.PLAYER1, {
                up: 'ArrowUp',
                down: 'ArrowDown',
                left: 'ArrowLeft',
                right: 'ArrowRight'
            }));

            if (gameMode === 'two') {
                // Player 2 (Bottom-right corner)
                players.push(new Player(2, GRID_SIZE - 1, GRID_SIZE - 1, COLORS.PLAYER2, {
                    up: 'w',
                    down: 's',
                    left: 'a',
                    right: 'd'
                }));
            } else {
                 // Simple AI player for single player mode (Bottom-right corner)
                 players.push(new Player(2, GRID_SIZE - 1, GRID_SIZE - 1, COLORS.PLAYER2, null)); // No controls for AI
            }

            // Set canvas size based on grid and block size
            canvas.width = GRID_SIZE * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_GAP;
            canvas.height = GRID_SIZE * (BLOCK_SIZE + BLOCK_GAP) + BLOCK_GAP;

            gameInfo.textContent = window.innerWidth > 768 ? 'Use Arrow Keys (P1) and WASD (P2) to move' : ''; // Show keyboard info only on desktop

            gameLoop(); // Start the game loop
        }

        function update() {
            if (!gameRunning) return;

            // Update blocks
            grid.forEach(block => block.update());

            // Check if players are on broken blocks
            players.forEach(player => {
                if (!player.isAlive) return;

                const blockIndex = player.gridY * GRID_SIZE + player.gridX;
                if (grid[blockIndex] && grid[blockIndex].state === 'broken') {
                    player.isAlive = false;
                }
            });

            // AI logic for single player mode
            if (gameMode === 'single' && players[1].isAlive) {
                const aiPlayer = players[1];
                 // Smarter AI: Try to move to an adjacent solid block that is not already a warning
                if (Date.now() - aiPlayer.moveTimer >= aiPlayer.moveDelay * 1.5) { // AI moves slightly slower
                    const possibleMoves = [];
                    const moves = [[0, -1], [0, 1], [-1, 0], [1, 0]]; // Up, Down, Left, Right

                    // Prioritize moves to solid blocks
                    moves.forEach(move => {
                        const newX = aiPlayer.gridX + move[0];
                        const newY = aiPlayer.gridY + move[1];
                        const blockIndex = newY * GRID_SIZE + newX;

                        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                            if (grid[blockIndex] && grid[blockIndex].state === 'solid') {
                                possibleMoves.push(move);
                            }
                        }
                    });

                    // If no solid blocks, consider warning blocks as a last resort
                    if (possibleMoves.length === 0) {
                         moves.forEach(move => {
                            const newX = aiPlayer.gridX + move[0];
                            const newY = aiPlayer.gridY + move[1];
                            const blockIndex = newY * GRID_SIZE + newX;

                            if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                                if (grid[blockIndex] && grid[blockIndex].state === 'warning') {
                                    possibleMoves.push(move);
                                }
                            }
                        });
                    }


                    if (possibleMoves.length > 0) {
                        // Choose a random move from the possible moves
                        const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                        aiPlayer.move(randomMove[0], randomMove[1]);
                    } else {
                         // If no solid or warning adjacent blocks, the AI is trapped and will eventually fall
                    }
                }
            }

            // Check for game over
            const alivePlayers = players.filter(player => player.isAlive);
            if (alivePlayers.length <= 1) {
                gameRunning = false;
                setTimeout(() => { // Delay game over screen slightly
                    showGameOver(alivePlayers.length === 1 ? alivePlayers[0] : null);
                }, 500);
            }
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = COLORS.BACKGROUND;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw blocks
            grid.forEach(block => block.draw());

            // Draw players
            players.forEach(player => player.draw());
        }

        function gameLoop() {
            update();
            draw();

            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        function showGameOver(winner) {
            canvas.style.display = 'none'; // Hide canvas
            mobileControls.style.display = 'none'; // Hide mobile controls
            gameOverScreen.classList.remove('hidden');
            if (winner) {
                // Display winner by color
                let winnerColorName = 'Unknown Color';
                for (const colorName in COLORS) {
                    if (COLORS[colorName] === winner.color) {
                        winnerColorName = colorName.replace('PLAYER', 'Player '); // Convert PLAYER1 to Player 1
                        break;
                    }
                }
                winnerInfo.textContent = `${winnerColorName} Wins!`;
            } else {
                winnerInfo.textContent = 'It\'s a Draw!';
            }
        }

        // Event Listeners
        singlePlayerBtn.addEventListener('click', () => initGame('single'));
        twoPlayerBtn.addEventListener('click', () => initGame('two'));

        // Main Menu button event listener
        mainMenuButton.addEventListener('click', () => {
            gameOverScreen.classList.add('hidden'); // Hide game over screen
            startScreen.classList.remove('hidden'); // Show start screen
            canvas.style.display = 'none'; // Hide canvas
            mobileControls.style.display = 'none'; // Hide mobile controls
            gameRunning = false; // Ensure game loop stops
        });


        // Keyboard Controls
        document.addEventListener('keydown', (event) => {
            if (!gameRunning) return;

            players.forEach(player => {
                if (player.isAlive && player.controls) {
                    switch (event.key) {
                        case player.controls.up:
                            player.move(0, -1);
                            break;
                        case player.controls.down:
                            player.move(0, 1);
                            break;
                        case player.controls.left:
                            player.move(-1, 0);
                            break;
                        case player.controls.right:
                            player.move(1, 0);
                            break;
                    }
                }
            });
        });

        // Mobile Touch Controls
        controlButtons.forEach(button => {
            button.addEventListener('touchstart', (event) => {
                event.preventDefault(); // Prevent scrolling/zooming
                // In single player mode, only player 1 uses mobile controls
                // In two player mode, we'd need a way to distinguish which player is using controls
                // For simplicity, mobile controls currently only affect Player 1
                if (!gameRunning || (gameMode === 'two' && players[0].controls === null)) return; // Only P1 in single or if P1 has controls in two player

                const direction = button.dataset.direction;
                const controlledPlayer = gameMode === 'single' ? players[0] : players.find(p => p.controls !== null); // Get the human-controlled player

                if (controlledPlayer) {
                    switch (direction) {
                        case 'up':
                            controlledPlayer.move(0, -1);
                            break;
                        case 'down':
                            controlledPlayer.move(0, 1);
                            break;
                        case 'left':
                            controlledPlayer.move(-1, 0);
                            break;
                        case 'right':
                            controlledPlayer.move(1, 0);
                            break;
                    }
                }
            });
             // Add touchend to prevent continuous movement if needed, or rely on moveDelay
             // button.addEventListener('touchend', (event) => { event.preventDefault(); });
        });


        // Handle window resize to maintain responsiveness
        window.addEventListener('resize', () => {
             if (gameRunning) {
                // Recalculate canvas size based on current container size or desired logic
                // For simplicity, we'll just redraw with current settings,
                // but a more robust solution might adjust BLOCK_SIZE based on container width.
                // For this example, we'll rely on max-width and auto height in CSS.
                draw(); // Redraw to ensure everything is centered correctly
             }
             // Adjust visibility of mobile controls based on window size and game state
             mobileControls.style.display = window.innerWidth <= 768 && gameRunning ? 'block' : 'none';
             gameInfo.style.display = window.innerWidth > 768 && gameRunning ? 'block' : 'none';
        });

        // Ensure Tone.js audio context is resumed on a user gesture (like button click)
        // This is a common requirement in modern browsers for audio playback
        document.addEventListener('click', () => {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                Tone.context.resume();
            }
        });


        // Initial drawing of the start screen
        draw(); // Draw the initial state (empty canvas behind start screen)

    </script>
</body>
</html>
